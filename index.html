<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>í† í° ê²Œì„ - í•µì‹¬ ì»¨ì…‰ í”„ë¡œí† íƒ€ì…</title>
    <style>
        body {
            font-family: monospace;
            max-width: 1000px;
            margin: 20px auto;
            padding: 20px;
            background: #1a1a1a;
            color: #eee;
        }
        .section {
            margin: 20px 0;
            padding: 15px;
            border: 2px solid #444;
            background: #252525;
        }
        .card {
            display: inline-block;
            padding: 10px;
            margin: 5px;
            border: 2px solid #666;
            background: #333;
            cursor: pointer;
            min-width: 120px;
        }
        .card.selected {
            border-color: #4a9eff;
            background: #1a3a5a;
        }
        .card.grade-A {
            border-left: 4px solid #4a9eff;
        }
        .card.grade-C {
            border-left: 4px solid #ff9a4a;
        }
        .card-text {
            font-size: 14px;
        }
        .card-cost {
            font-size: 11px;
            color: #aaa;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            background: #444;
            color: #eee;
            border: 2px solid #666;
            cursor: pointer;
            font-family: monospace;
        }
        button:hover {
            background: #555;
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .result {
            padding: 10px;
            margin: 10px 0;
            background: #1a1a1a;
            border-left: 4px solid #666;
        }
        .result.surge { border-left-color: #ff4a4a; }
        .result.perfect { border-left-color: #4aff4a; }
        .result.cut { border-left-color: #ffaa4a; }
        .log {
            font-size: 12px;
            color: #999;
            max-height: 200px;
            overflow-y: auto;
        }
        .enemy {
            display: inline-block;
            margin: 10px;
            padding: 15px;
            border: 2px solid #666;
            background: #2a2a2a;
            min-width: 150px;
        }
        .enemy.dead {
            opacity: 0.3;
            border-color: #333;
        }
        .enemy-name {
            font-size: 14px;
            margin-bottom: 5px;
        }
        .hp-bar {
            width: 100%;
            height: 20px;
            background: #1a1a1a;
            border: 1px solid #666;
            margin-top: 5px;
            position: relative;
        }
        .hp-fill {
            height: 100%;
            background: #ff4a4a;
            transition: width 0.3s;
        }
        .hp-text {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            text-align: center;
            line-height: 20px;
            font-size: 11px;
            color: #fff;
        }
    </style>
</head>
<body>
    <h1>ğŸ® í† í° ê²Œì„ - ì»¨ì…‰ ê²€ì¦ í”„ë¡œí† íƒ€ì…</h1>

    <div class="section">
        <h3>ğŸ‘¾ ì  (ENEMIES)</h3>
        <div id="enemies"></div>
    </div>

    <div class="section">
        <h3>ğŸ“Š ê²Œì„ ìƒíƒœ</h3>
        <div>í„´: <span id="turn">1</span></div>
        <div>
            â¤ï¸ ì²´ë ¥: <span id="player-hp">30</span> / 30 |
            ğŸ›¡ï¸ ë°©ì–´ë ¥: <span id="player-shield">0</span>
        </div>
        <div>ì¶”ë¡  í’€: <span id="reasoning-pool">5</span> / 5</div>
        <div>ë±: <span id="deck-count">20</span>ì¥ | ë²„ë¦° ë±: <span id="discard-count">0</span>ì¥</div>
    </div>

    <div class="section">
        <h3>ğŸ–ï¸ ì•¡í‹°ë¸Œ í•¸ë“œ (5ì¥ ê³ ì •)</h3>
        <div id="hand"></div>
        <p style="font-size: 12px; color: #999;">í´ë¦­í•´ì„œ ì¹´ë“œ ì„ íƒ/í•´ì œ</p>
    </div>

    <div class="section">
        <h3>ğŸ“ ì¡°ë¦½ëœ í”„ë¡¬í”„íŠ¸</h3>
        <div id="prompt">
            <p style="color: #666;">ì¹´ë“œë¥¼ ì„ íƒí•˜ì„¸ìš”...</p>
        </div>
        <div>
            ì„ íƒí•œ ì¹´ë“œ ìˆ˜: <span id="selected-count">0</span> |
            ì´ ë¹„ìš©: <span id="total-cost">0</span> / 5
        </div>
        <button id="execute-btn" onclick="executePrompt()" disabled>ğŸš€ í”„ë¡¬í”„íŠ¸ ì‹¤í–‰</button>
        <button onclick="clearSelection()">ğŸ”„ ì„ íƒ ì´ˆê¸°í™”</button>
    </div>

    <div class="section">
        <h3>âš¡ ì¶”ë¡  ê²°ê³¼</h3>
        <div id="result">
            <p style="color: #666;">í”„ë¡¬í”„íŠ¸ë¥¼ ì‹¤í–‰í•˜ì„¸ìš”...</p>
        </div>
    </div>

    <div class="section">
        <h3>ğŸ“œ ê²Œì„ ë¡œê·¸</h3>
        <div id="log" class="log"></div>
    </div>

    <script>
        // ========== ë°ì´í„° êµ¬ì¡° ==========
        const CARD_POOL = [
            { id: 1, grade: 'A', type: 'target', text: 'ì  1ì²´', cost: 1, count: 3 },
            { id: 2, grade: 'A', type: 'action', text: 'í”¼í•´ 3', cost: 2, count: 3 },
            { id: 3, grade: 'A', type: 'action', text: 'ë°©ì–´ 5', cost: 2, count: 3 },
            { id: 4, grade: 'A', type: 'target', text: 'ì  ì „ì²´', cost: 3, count: 1 },
            { id: 5, grade: 'C', type: 'target', text: 'ëª¨ë‘ì—ê²Œ', cost: 3, count: 1 },
            { id: 6, grade: 'C', type: 'modifier', text: 'ëœ¨ê±°ì›€', cost: 2, count: 3 },
            { id: 7, grade: 'A', type: 'action', text: 'í”¼í•´ 2', cost: 1, count: 3 },
            { id: 8, grade: 'A', type: 'action', text: '2íšŒ', cost: 1, count: 1 },
        ];

        let gameState = {
            turn: 1,
            reasoningPool: 5,
            maxReasoningPool: 5,
            hand: [],
            library: [],
            discardPile: [],
            selectedCards: new Set(),
            enemies: [
                { id: 1, name: 'ìŠ¬ë¼ì„', hp: 10, maxHp: 10, nextAction: null },
                { id: 2, name: 'ê³ ë¸”ë¦°', hp: 15, maxHp: 15, nextAction: null },
                { id: 3, name: 'ì˜¤í¬', hp: 20, maxHp: 20, nextAction: null }
            ],
            playerHp: 30,
            maxPlayerHp: 30,
            playerShield: 0
        };

        // ========== ì´ˆê¸°í™” ==========
        function initGame() {
            // ë± ìƒì„± (ê° ì¹´ë“œì˜ countë§Œí¼ ì¶”ê°€)
            gameState.library = [];
            CARD_POOL.forEach(card => {
                for (let i = 0; i < card.count; i++) {
                    gameState.library.push({ ...card, uniqueId: `${card.id}-${i}` });
                }
            });
            shuffle(gameState.library);

            // ì´ˆê¸° í•¸ë“œ 5ì¥
            drawCards(5);

            // ì ë“¤ì˜ ë‹¤ìŒ í–‰ë™ ê²°ì •
            gameState.enemies.forEach(enemy => {
                planEnemyAction(enemy);
            });

            updateUI();
            log('ê²Œì„ ì‹œì‘! í•¸ë“œ 5ì¥ ë“œë¡œìš°');
        }

        // ========== ì  í–‰ë™ ê³„íš ==========
        function planEnemyAction(enemy) {
            if (enemy.hp <= 0) {
                enemy.nextAction = null;
                return;
            }

            // ì  ì¢…ë¥˜ì— ë”°ë¼ ë‹¤ë¥¸ ê³µê²© íŒ¨í„´
            let damage = 0;
            if (enemy.name === 'ìŠ¬ë¼ì„') {
                damage = Math.random() < 0.5 ? 2 : 3;
            } else if (enemy.name === 'ê³ ë¸”ë¦°') {
                damage = Math.random() < 0.5 ? 3 : 4;
            } else if (enemy.name === 'ì˜¤í¬') {
                damage = Math.random() < 0.5 ? 5 : 6;
            }

            enemy.nextAction = { type: 'attack', damage: damage };
        }

        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function drawCards(count) {
            for (let i = 0; i < count; i++) {
                if (gameState.library.length === 0) {
                    // ë±ì´ ë¹„ì—ˆìœ¼ë©´ ë²„ë¦° ë± ì…”í”Œí•´ì„œ ì¬í™œìš©
                    if (gameState.discardPile.length > 0) {
                        log('âŸ³ ë± ì†Œì§„! ë²„ë¦° ë±ì„ ì…”í”Œí•˜ì—¬ ì¬í™œìš©');
                        gameState.library = [...gameState.discardPile];
                        gameState.discardPile = [];
                        shuffle(gameState.library);
                    } else {
                        log('âš ï¸ ë” ì´ìƒ ë½‘ì„ ì¹´ë“œê°€ ì—†ìŠµë‹ˆë‹¤!');
                        break;
                    }
                }

                const card = gameState.library.shift();
                gameState.hand.push(card);
            }
        }

        // ========== UI ì—…ë°ì´íŠ¸ ==========
        function updateUI() {
            // ì  ë Œë”ë§
            const enemiesEl = document.getElementById('enemies');
            enemiesEl.innerHTML = '';
            gameState.enemies.forEach(enemy => {
                const enemyEl = document.createElement('div');
                enemyEl.className = `enemy ${enemy.hp <= 0 ? 'dead' : ''}`;
                const hpPercent = (enemy.hp / enemy.maxHp) * 100;

                let actionText = '';
                if (enemy.hp > 0 && enemy.nextAction) {
                    if (enemy.nextAction.type === 'attack') {
                        actionText = `<div style="color: #ff9a4a; font-size: 12px; margin-top: 5px;">âš”ï¸ ê³µê²© ì˜ˆì •: ${enemy.nextAction.damage} í”¼í•´</div>`;
                    }
                }

                enemyEl.innerHTML = `
                    <div class="enemy-name">${enemy.name}</div>
                    <div class="hp-bar">
                        <div class="hp-fill" style="width: ${hpPercent}%"></div>
                        <div class="hp-text">${Math.max(0, enemy.hp)} / ${enemy.maxHp}</div>
                    </div>
                    ${actionText}
                `;
                enemiesEl.appendChild(enemyEl);
            });

            // ìƒíƒœ í‘œì‹œ
            document.getElementById('turn').textContent = gameState.turn;
            document.getElementById('reasoning-pool').textContent = gameState.reasoningPool;
            document.getElementById('player-hp').textContent = gameState.playerHp;
            document.getElementById('player-shield').textContent = gameState.playerShield;
            document.getElementById('deck-count').textContent = gameState.library.length;
            document.getElementById('discard-count').textContent = gameState.discardPile.length;

            // í•¸ë“œ ë Œë”ë§
            const handEl = document.getElementById('hand');
            handEl.innerHTML = '';
            gameState.hand.forEach(card => {
                const cardEl = document.createElement('div');
                cardEl.className = `card grade-${card.grade}`;
                if (gameState.selectedCards.has(card.uniqueId)) {
                    cardEl.classList.add('selected');
                }
                cardEl.innerHTML = `
                    <div class="card-text">[${card.grade}: ${card.text}]</div>
                    <div class="card-cost">ë¹„ìš©: ${card.cost}</div>
                `;
                cardEl.onclick = () => toggleCard(card.uniqueId);
                handEl.appendChild(cardEl);
            });

            // í”„ë¡¬í”„íŠ¸ í‘œì‹œ
            updatePrompt();
        }

        function toggleCard(uniqueId) {
            if (gameState.selectedCards.has(uniqueId)) {
                gameState.selectedCards.delete(uniqueId);
            } else {
                gameState.selectedCards.add(uniqueId);
            }
            updatePrompt();
            updateUI();
        }

        function clearSelection() {
            gameState.selectedCards.clear();
            updatePrompt();
            updateUI();
        }

        function updatePrompt() {
            const selectedArray = gameState.hand.filter(c => gameState.selectedCards.has(c.uniqueId));
            const totalCost = selectedArray.reduce((sum, c) => sum + c.cost, 0);

            const promptEl = document.getElementById('prompt');
            if (selectedArray.length === 0) {
                promptEl.innerHTML = '<p style="color: #666;">ì¹´ë“œë¥¼ ì„ íƒí•˜ì„¸ìš”...</p>';
            } else {
                const text = selectedArray.map(c => `[${c.grade}: ${c.text}]`).join(' + ');
                promptEl.innerHTML = `<p>${text}</p>`;
            }

            document.getElementById('selected-count').textContent = selectedArray.length;
            document.getElementById('total-cost').textContent = totalCost;

            // ì‹¤í–‰ ë²„íŠ¼ í™œì„±í™”
            const executeBtn = document.getElementById('execute-btn');
            executeBtn.disabled = selectedArray.length === 0;
        }

        // ========== ì¶”ë¡  ì‹œìŠ¤í…œ ==========
        function executePrompt() {
            const selectedArray = gameState.hand.filter(c => gameState.selectedCards.has(c.uniqueId));
            if (selectedArray.length === 0) return;

            const totalCost = selectedArray.reduce((sum, c) => sum + c.cost, 0);
            const diff = gameState.reasoningPool - totalCost;

            let resultType, resultText, usedTokens, cutTokens = [];
            let damageBonus = 1.0;
            let repeatCount = 1;

            // '2íšŒ' í† í° ì²´í¬
            const hasTwoTimesToken = selectedArray.some(c => c.text === '2íšŒ');
            if (hasTwoTimesToken) {
                repeatCount = 2;
            }

            if (diff > 0) {
                // ê³¼ì¶”ë¡  (Surge)
                resultType = 'surge';
                resultText = `ğŸ”¥ SURGE! (ë‚¨ì€ ì¶”ë¡ : ${diff})`;
                resultText += `<br>â†’ ë³´ë„ˆìŠ¤: íš¨ê³¼ +50%`;
                usedTokens = selectedArray;
                damageBonus = 1.5;
            } else if (diff === 0) {
                // ì™„ì „ ì¶”ë¡  (Perfect)
                resultType = 'perfect';
                resultText = `âœ¨ PERFECT! (ì •í™•íˆ ì¼ì¹˜)`;
                resultText += `<br>â†’ ë³´ë„ˆìŠ¤: íš¨ê³¼ 2íšŒ ë°œë™`;
                usedTokens = selectedArray;
                repeatCount = hasTwoTimesToken ? 4 : 2;  // '2íšŒ' í† í°ê³¼ Perfect ì¤‘ì²©ì‹œ 4íšŒ
            } else {
                // ì¶”ë¡  ì‹¤íŒ¨ (Cut)
                resultType = 'cut';
                const cutCount = Math.ceil(Math.abs(diff) / 2); // ê°„ë‹¨íˆ 2ë¡œ ë‚˜ëˆ”
                const actualCut = Math.min(cutCount, selectedArray.length);

                cutTokens = selectedArray.slice(-actualCut);
                usedTokens = selectedArray.slice(0, -actualCut);

                resultText = `âš ï¸ CUT! (ë¶€ì¡±í•œ ì¶”ë¡ : ${Math.abs(diff)})`;
                resultText += `<br>â†’ ë’¤ì—ì„œ ${actualCut}ì¥ ì œê±°ë¨: `;
                resultText += cutTokens.map(c => `[${c.text}]`).join(', ');
            }

            // í† í° í•´ì„
            const interpretation = interpretTokens(usedTokens);

            // ì „íˆ¬ ë¡œì§ ì‹¤í–‰
            const combatResult = executeCombat(usedTokens, damageBonus, repeatCount);

            // ê²°ê³¼ í‘œì‹œ
            const resultEl = document.getElementById('result');
            resultEl.innerHTML = `
                <div class="result ${resultType}">
                    <strong>${resultText}</strong>
                    <br><br>
                    ${interpretation}
                    <br>
                    ${combatResult}
                    <br>
                    <details style="margin-top: 10px;">
                        <summary style="cursor: pointer; color: #999;">ì‚¬ìš©ëœ í† í° ìƒì„¸ (í´ë¦­)</summary>
                        <div style="margin-top: 5px; padding: 5px; background: #1a1a1a;">
                            ${usedTokens.map(c => `[${c.grade}: ${c.text}] (ë¹„ìš© ${c.cost})`).join('<br>')}
                            ${usedTokens.length === 0 ? '<span style="color: #999;">ì—†ìŒ (ëª¨ë‘ ì˜ë ¸ìŠµë‹ˆë‹¤)</span>' : ''}
                        </div>
                    </details>
                </div>
            `;

            log(`í„´ ${gameState.turn}: ${resultType.toUpperCase()} - ${selectedArray.length}ì¥ ì‚¬ìš©, ì´ ë¹„ìš© ${totalCost}`);

            // UI ì—…ë°ì´íŠ¸ (ì  ì²´ë ¥ ë°˜ì˜)
            updateUI();

            // í„´ ì¢…ë£Œ ì²˜ë¦¬
            endTurn(selectedArray);
        }

        // ========== í† í° í•´ì„ ==========
        function interpretTokens(tokens) {
            let interpretation = '<strong>ğŸ“– í”„ë¡¬í”„íŠ¸ í•´ì„:</strong><br>';
            interpretation += '<div style="background: #1a1a2a; padding: 10px; margin: 5px 0; border-left: 3px solid #4a9eff;">';

            if (tokens.length === 0) {
                interpretation += '<span style="color: #666;">ì¶”ë¡  ì‹¤íŒ¨ë¡œ ëª¨ë“  í† í°ì´ ì œê±°ë¨</span>';
                interpretation += '</div>';
                return interpretation;
            }

            // í† í° ë¶„ì„
            const targets = tokens.filter(t => t.type === 'target');
            const actions = tokens.filter(t => t.type === 'action');
            const modifiers = tokens.filter(t => t.type === 'modifier');

            const damageActions = actions.filter(t => t.text.includes('í”¼í•´'));
            const defenseActions = actions.filter(t => t.text.includes('ë°©ì–´'));

            // === ê²½ìš°ë³„ í•´ì„ ===

            // íƒ€ê²Ÿë§Œ ìˆìŒ
            if (targets.length > 0 && actions.length === 0) {
                const targetText = targets[0].text.includes('ì „ì²´') ? 'ëª¨ë“  ì ' : 'ì ';
                interpretation += `"<strong>${targetText}</strong>ì„(ë¥¼) ë…¸ë ¤ë³¸ë‹¤`;
                if (modifiers.length > 0) {
                    interpretation += ` (<strong>${modifiers.map(m => m.text).join(', ')}</strong>)`;
                }
                interpretation += `" <span style="color: #999;">â†’ í–‰ë™ ì—†ìŒ</span>`;
                interpretation += '</div>';
                return interpretation;
            }

            // ì•¡ì…˜ë§Œ ìˆìŒ (íƒ€ê²Ÿ ì—†ìŒ)
            if (actions.length > 0 && targets.length === 0) {
                let actionParts = [];

                if (damageActions.length > 0) {
                    damageActions.forEach(card => {
                        const match = card.text.match(/í”¼í•´\s*(\d+)/);
                        if (match) {
                            actionParts.push(`í”¼í•´ ${match[1]}`);
                        }
                    });
                }

                if (defenseActions.length > 0) {
                    defenseActions.forEach(card => {
                        const match = card.text.match(/ë°©ì–´\s*(\d+)/);
                        if (match) {
                            actionParts.push(`ë°©ì–´ ${match[1]}`);
                        }
                    });
                }

                // '2íšŒ' í† í°
                actions.forEach(card => {
                    if (card.text === '2íšŒ') {
                        actionParts.push(`2íšŒ ì‹¤í–‰`);
                    }
                });

                interpretation += `"<strong>${actionParts.join(' + ')}</strong>`;
                if (modifiers.length > 0) {
                    interpretation += ` (<strong>${modifiers.map(m => m.text).join(', ')}</strong>)`;
                }
                interpretation += `" <span style="color: #999;">â†’ íƒ€ê²Ÿ ì—†ìŒ</span>`;
                interpretation += '</div>';
                return interpretation;
            }

            // ìˆ˜ì‹ì–´ë§Œ ìˆìŒ
            if (modifiers.length > 0 && actions.length === 0 && targets.length === 0) {
                interpretation += `"<strong>${modifiers.map(m => m.text).join(', ')}</strong>!" <span style="color: #999;">â†’ ë¬´ì˜ë¯¸í•œ í–‰ë™</span>`;
                interpretation += '</div>';
                return interpretation;
            }

            // ì •ìƒ ì¡°í•© (íƒ€ê²Ÿ + ì•¡ì…˜)
            let targetText = '';
            if (targets.some(t => t.text.includes('ì  ì „ì²´') || t.text.includes('ëª¨ë‘'))) {
                targetText = 'ëª¨ë“  ì ';
            } else if (targets.some(t => t.text.includes('ì  1ì²´'))) {
                targetText = 'ì  1ì²´';
            } else {
                targetText = '???';
            }

            let actionParts = [];
            actions.forEach(card => {
                if (card.text.includes('í”¼í•´')) {
                    const match = card.text.match(/í”¼í•´\s*(\d+)/);
                    if (match) {
                        actionParts.push(`í”¼í•´ ${match[1]}`);
                    }
                } else if (card.text.includes('ë°©ì–´')) {
                    const match = card.text.match(/ë°©ì–´\s*(\d+)/);
                    if (match) {
                        actionParts.push(`ë°©ì–´ ${match[1]}`);
                    }
                } else if (card.text === '2íšŒ') {
                    actionParts.push(`2íšŒ ì‹¤í–‰`);
                }
            });

            let modifierText = '';
            if (modifiers.length > 0) {
                modifierText = ' (<strong>' + modifiers.map(m => m.text).join(', ') + '</strong>)';
            }

            if (actionParts.length > 0) {
                interpretation += `"<strong>${targetText}</strong>ì—ê²Œ <strong>${actionParts.join(' + ')}</strong>${modifierText}"`;
            } else {
                interpretation += '<span style="color: #999;">ì•Œ ìˆ˜ ì—†ëŠ” ì¡°í•©</span>';
            }

            interpretation += '</div>';
            return interpretation;
        }

        // ========== ì „íˆ¬ ë¡œì§ ==========
        function executeCombat(tokens, damageBonus, repeatCount) {
            let combatLog = '<strong>âš”ï¸ ì „íˆ¬ ê²°ê³¼:</strong><br>';

            // í† í° ë¶„ì„
            const targets = tokens.filter(t => t.type === 'target');
            const actions = tokens.filter(t => t.type === 'action');
            const modifiers = tokens.filter(t => t.type === 'modifier');

            const damageCards = actions.filter(t => t.text.includes('í”¼í•´'));
            const defenseCards = actions.filter(t => t.text.includes('ë°©ì–´'));

            // === ê²½ìš° 1: í† í°ì´ í•˜ë‚˜ë„ ì—†ìŒ (Cutìœ¼ë¡œ ëª¨ë‘ ì˜ë¦¼) ===
            if (tokens.length === 0) {
                combatLog += '<span style="color: #666;">ğŸ’­ ì¶”ë¡  ì‹¤íŒ¨... ì•„ë¬´ ì¼ë„ ì¼ì–´ë‚˜ì§€ ì•Šì•˜ë‹¤.</span><br>';
                return combatLog;
            }

            // === ê²½ìš° 2: íƒ€ê²Ÿë§Œ ìˆê³  ì•¡ì…˜ì´ ì—†ìŒ ===
            if (targets.length > 0 && actions.length === 0) {
                const targetName = targets[0].text.includes('ì „ì²´') ? 'ëª¨ë“  ì ' : 'ì ';
                combatLog += `<span style="color: #999;">ğŸ‘ï¸ ${targetName}ì„(ë¥¼) ë…¸ë ¤ë³´ì•˜ë‹¤... í•˜ì§€ë§Œ í–‰ë™ì´ ì—†ì–´ ì•„ë¬´ ì¼ë„ ì¼ì–´ë‚˜ì§€ ì•Šì•˜ë‹¤.</span><br>`;

                // ìˆ˜ì‹ì–´ê°€ ìˆìœ¼ë©´ ì–¸ê¸‰
                if (modifiers.length > 0) {
                    combatLog += `<span style="color: #777;">(${modifiers.map(m => m.text).join(', ')}í•œ ëŠë‚Œì´ì—ˆë‹¤)</span><br>`;
                }
                return combatLog;
            }

            // === ê²½ìš° 3: ì•¡ì…˜ë§Œ ìˆê³  íƒ€ê²Ÿì´ ì—†ìŒ ===
            if (actions.length > 0 && targets.length === 0) {
                // ë°©ì–´ ì¹´ë“œê°€ ìˆìœ¼ë©´ ìì‹ ì—ê²Œ ì ìš©
                if (defenseCards.length > 0) {
                    let totalDefense = 0;
                    defenseCards.forEach(card => {
                        const match = card.text.match(/ë°©ì–´\s*(\d+)/);
                        if (match) {
                            totalDefense += parseInt(match[1]);
                        }
                    });

                    totalDefense = Math.floor(totalDefense * damageBonus * repeatCount);
                    gameState.playerShield += totalDefense;

                    combatLog += `<span style="color: #4a9eff;">ğŸ›¡ï¸ ë°©ì–´ íƒœì„¸! ë°©ì–´ë ¥ +${totalDefense}</span><br>`;
                    if (damageBonus > 1.0) {
                        combatLog += `<span style="color: #ff9a4a;">(Surge ë³´ë„ˆìŠ¤ ì ìš©!)</span><br>`;
                    }
                    if (repeatCount > 1) {
                        combatLog += `<span style="color: #4aff9a;">(Perfect! ${repeatCount}íšŒ ì ìš©)</span><br>`;
                    }
                    return combatLog;
                }

                // í”¼í•´ ì¹´ë“œë§Œ ìˆìœ¼ë©´ í—ˆê³µì— ê³µê²©
                if (damageCards.length > 0) {
                    let totalDamage = 0;
                    damageCards.forEach(card => {
                        const match = card.text.match(/í”¼í•´\s*(\d+)/);
                        if (match) {
                            totalDamage += parseInt(match[1]);
                        }
                    });

                    combatLog += `<span style="color: #999;">ğŸ’¨ íƒ€ê²Ÿì´ ì—†ì–´ í—ˆê³µì„ ê³µê²©í–ˆë‹¤! (í”¼í•´ ${totalDamage}ì€(ëŠ”) í—ˆê³µìœ¼ë¡œ ì‚¬ë¼ì¡Œë‹¤)</span><br>`;

                    // ìš´ì´ ì¢‹ìœ¼ë©´ ì²« ë²ˆì§¸ ì ì—ê²Œ 1 í”¼í•´
                    if (Math.random() < 0.3) {
                        const target = gameState.enemies.find(e => e.hp > 0);
                        if (target) {
                            target.hp -= 1;
                            combatLog += `<span style="color: #ffaa4a;">âœ¨ ìš´ì´ ì¢‹ê²Œë„ ${target.name}ì—ê²Œ ë¹—ë§ì•˜ë‹¤! (1 í”¼í•´)</span><br>`;
                        }
                    }
                    return combatLog;
                }
            }

            // === ê²½ìš° 4: ìˆ˜ì‹ì–´ë§Œ ìˆìŒ ===
            if (modifiers.length > 0 && actions.length === 0) {
                const modifierEffects = [
                    'ë©‹ì§„ í¬ì¦ˆë¥¼ ì·¨í–ˆë‹¤!',
                    'ê¸°ì„¸ê°€ ë“±ë“±í•´ì¡Œë‹¤!',
                    'ì ë“¤ì´ ì¡°ê¸ˆ ê¸´ì¥í•œ ê²ƒ ê°™ë‹¤.',
                    'ë¶„ìœ„ê¸°ê°€ ë°”ë€Œì—ˆë‹¤... í•˜ì§€ë§Œ ì‹¤ì§ˆì ì¸ íš¨ê³¼ëŠ” ì—†ë‹¤.'
                ];
                const randomEffect = modifierEffects[Math.floor(Math.random() * modifierEffects.length)];
                combatLog += `<span style="color: #aa99ff;">ğŸŒŸ ${modifiers.map(m => m.text).join(', ')}! ${randomEffect}</span><br>`;
                return combatLog;
            }

            // === ê²½ìš° 5: ì •ìƒì ì¸ ê³µê²© (íƒ€ê²Ÿ + í”¼í•´) ===
            if (damageCards.length > 0) {
                // ê¸°ë³¸ í”¼í•´ ê³„ì‚°
                let baseDamage = 0;
                damageCards.forEach(card => {
                    const match = card.text.match(/í”¼í•´\s*(\d+)/);
                    if (match) {
                        baseDamage += parseInt(match[1]);
                    }
                });

                // íƒ€ê²Ÿ ê²°ì •
                let targetType = 'single'; // ê¸°ë³¸: ë‹¨ì¼
                if (targets.some(t => t.text.includes('ì  ì „ì²´') || t.text.includes('ëª¨ë‘'))) {
                    targetType = 'all';
                }

                // ë³´ë„ˆìŠ¤ ì„¤ëª…
                const hasTwoTimesToken = tokens.some(t => t.text === '2íšŒ');

                if (damageBonus > 1.0 && repeatCount > 1) {
                    combatLog += `<span style="color: #ff9a4a;">ê¸°ë³¸ í”¼í•´ ${baseDamage} â†’ Surge ë³´ë„ˆìŠ¤ ì ìš© â†’ ${Math.floor(baseDamage * damageBonus)} í”¼í•´</span><br>`;
                    combatLog += `<span style="color: #4aff9a;">'2íšŒ' í† í°ìœ¼ë¡œ ${repeatCount}íšŒ ì‹¤í–‰!</span><br>`;
                } else if (damageBonus > 1.0) {
                    combatLog += `<span style="color: #ff9a4a;">ê¸°ë³¸ í”¼í•´ ${baseDamage} â†’ Surge ë³´ë„ˆìŠ¤ ì ìš© â†’ ${Math.floor(baseDamage * damageBonus)} í”¼í•´</span><br>`;
                } else if (repeatCount > 1 && hasTwoTimesToken) {
                    combatLog += `<span style="color: #4aff9a;">'2íšŒ' í† í°! í”¼í•´ ${baseDamage}ë¥¼ ${repeatCount}íšŒ ì‹¤í–‰</span><br>`;
                } else if (repeatCount > 1) {
                    combatLog += `<span style="color: #4aff9a;">Perfect! í”¼í•´ ${baseDamage}ë¥¼ ${repeatCount}íšŒ ì‹¤í–‰</span><br>`;
                } else {
                    combatLog += `<span style="color: #aaa;">í”¼í•´: ${baseDamage}</span><br>`;
                }

                // ë°˜ë³µ ì‹¤í–‰
                for (let i = 0; i < repeatCount; i++) {
                    if (repeatCount > 1) {
                        combatLog += `<br>[${i + 1}íšŒ ì‹¤í–‰]<br>`;
                    }

                    if (targetType === 'all') {
                        // ì „ì²´ ê³µê²©
                        const aliveEnemies = gameState.enemies.filter(e => e.hp > 0);
                        aliveEnemies.forEach(enemy => {
                            const finalDamage = Math.floor(baseDamage * damageBonus);
                            enemy.hp -= finalDamage;
                            combatLog += `â†’ ${enemy.name}ì—ê²Œ ${finalDamage} í”¼í•´`;
                            if (enemy.hp <= 0) {
                                combatLog += ` ğŸ’€ <strong>ì²˜ì¹˜!</strong>`;
                            }
                            combatLog += '<br>';
                        });
                    } else {
                        // ë‹¨ì¼ ê³µê²© (ì²« ë²ˆì§¸ ì‚´ì•„ìˆëŠ” ì )
                        const target = gameState.enemies.find(e => e.hp > 0);
                        if (target) {
                            const finalDamage = Math.floor(baseDamage * damageBonus);
                            target.hp -= finalDamage;
                            combatLog += `â†’ ${target.name}ì—ê²Œ ${finalDamage} í”¼í•´`;
                            if (target.hp <= 0) {
                                combatLog += ` ğŸ’€ <strong>ì²˜ì¹˜!</strong>`;
                            }
                            combatLog += '<br>';
                        }
                    }
                }
            }

            // ë°©ì–´ ì¹´ë“œ ì²˜ë¦¬ (í”¼í•´ì™€ í•¨ê»˜ ì‚¬ìš©ëœ ê²½ìš°)
            if (defenseCards.length > 0) {
                let totalDefense = 0;
                defenseCards.forEach(card => {
                    const match = card.text.match(/ë°©ì–´\s*(\d+)/);
                    if (match) {
                        totalDefense += parseInt(match[1]);
                    }
                });

                totalDefense = Math.floor(totalDefense * damageBonus * repeatCount);
                gameState.playerShield += totalDefense;

                combatLog += `<br><span style="color: #4a9eff;">ğŸ›¡ï¸ ë°©ì–´ë ¥ +${totalDefense}</span><br>`;
            }

            // ìŠ¹ë¦¬ ì¡°ê±´ ì²´í¬
            const allDead = gameState.enemies.every(e => e.hp <= 0);
            if (allDead) {
                combatLog += '<br>ğŸ‰ <strong>ëª¨ë“  ì  ì²˜ì¹˜! ìŠ¹ë¦¬!</strong>';
            }

            return combatLog;
        }

        // ========== ì  í„´ ì‹¤í–‰ ==========
        function executeEnemyTurn() {
            let enemyLog = '<br><strong>ğŸ¯ ì  í„´:</strong><br>';
            let anyAction = false;

            gameState.enemies.forEach(enemy => {
                if (enemy.hp <= 0 || !enemy.nextAction) return;

                anyAction = true;

                if (enemy.nextAction.type === 'attack') {
                    let damage = enemy.nextAction.damage;

                    // ë°©ì–´ë ¥ìœ¼ë¡œ í”¼í•´ ê°ì†Œ
                    if (gameState.playerShield > 0) {
                        const blocked = Math.min(damage, gameState.playerShield);
                        gameState.playerShield -= blocked;
                        damage -= blocked;

                        enemyLog += `â†’ ${enemy.name}ì˜ ê³µê²©! (${enemy.nextAction.damage} í”¼í•´)`;
                        if (blocked > 0) {
                            enemyLog += ` â†’ ë°©ì–´ë ¥ ${blocked} ì†Œëª¨`;
                        }
                        if (damage > 0) {
                            gameState.playerHp -= damage;
                            enemyLog += ` â†’ ${damage} í”¼í•´ ë°›ìŒ!`;
                        } else {
                            enemyLog += ` â†’ ì™„ì „íˆ ë°©ì–´!`;
                        }
                        enemyLog += '<br>';
                    } else {
                        gameState.playerHp -= damage;
                        enemyLog += `â†’ ${enemy.name}ì˜ ê³µê²©! ${damage} í”¼í•´!<br>`;
                    }
                }

                // ë‹¤ìŒ í–‰ë™ ì¬ê³„íš
                planEnemyAction(enemy);
            });

            if (anyAction) {
                const resultEl = document.getElementById('result');
                resultEl.innerHTML += enemyLog;
            }

            // íŒ¨ë°° ì¡°ê±´ ì²´í¬
            if (gameState.playerHp <= 0) {
                const resultEl = document.getElementById('result');
                resultEl.innerHTML += '<br>ğŸ’€ <strong>í”Œë ˆì´ì–´ ì‚¬ë§... íŒ¨ë°°!</strong>';
                log('ê²Œì„ ì˜¤ë²„!');
            }
        }

        // ========== í„´ ì¢…ë£Œ ==========
        function endTurn(usedCards) {
            // 1. ì  í„´ ì‹¤í–‰
            executeEnemyTurn();

            // 2. í•¸ë“œ ì „ì²´ë¥¼ ë²„ë¦° ë±ìœ¼ë¡œ
            gameState.discardPile.push(...gameState.hand);
            gameState.hand = [];

            log(`â†’ í•¸ë“œ ì „ì²´ ë²„ë¦¼, ìƒˆë¡œ 5ì¥ ë½‘ê¸°`);

            // 3. ìƒˆë¡œìš´ í•¸ë“œ 5ì¥ ë“œë¡œìš°
            drawCards(5);

            // 4. ì„ íƒ ì´ˆê¸°í™” ë° ë‹¤ìŒ í„´
            gameState.selectedCards.clear();
            gameState.turn++;
            gameState.reasoningPool = gameState.maxReasoningPool; // ì¶”ë¡  í’€ ë¦¬ì…‹

            updateUI();
            log(`--- í„´ ${gameState.turn} ì‹œì‘ ---`);
        }

        // ========== ë¡œê·¸ ==========
        function log(message) {
            const logEl = document.getElementById('log');
            const entry = document.createElement('div');
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logEl.insertBefore(entry, logEl.firstChild);
        }

        // ========== ê²Œì„ ì‹œì‘ ==========
        initGame();
    </script>
</body>
</html>
